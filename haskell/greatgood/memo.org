#+title: Learn You a Haskell for Great Good
#+author: matsuyoshi30

Haskell メモ

** Haskell とは

   非正格評価を特徴とする純粋関数型プログラミング言語

   非性格とは、関数に与えられた引数などの式はどうしても必要になるまで評価されないということ

   命令型は「何をするか」を定義し、関数型は「何であるか」を定義する

   純粋関数型は副作用を持たず、関数の処理結果が外部の環境などに作用されず、同じ引数を与えられれば常に同じ結果を返す（参照透過性）

   →ユーザーによる入力によってコンソールに出力する内容が変わる、というのも副作用

   →上記のケースは Haskell だと「関数はXXという内容をコンソールに書き出すIOモナドを生成して返却する」ように処理される


** Learn You a Haskell for Great Good

*** ch01

    演算子 +, -, *, / も関数の一つ（中置関数）

    関数はどの演算子よりも優先順位が高い

    if-then-else: if 文書くときは常に else も書く

    リストの操作には注意が必要で、結合時は結合される ++ の左のリストは先頭から末尾まで走査するので、対象のリストのサイズが大きいときはそれだけ実行時間がかかる。一方で、リストの先頭に何かを追加するような処理ははやい

    リスト内包表記によって take 10 [2,4..] が [x*2 | x <- [1..10]] と書ける

    各辺の長さが10以下で、各辺の合計が24である直角三角形の辺の組み合わせの求め方

    #+begin_src
    Prelude> let rightTriangles = [(a,b,c) | c <- [1..10], a <- [1..c], b <- [1..a], a^2 + b^2 == c^2, a+b+c==24]
    Prelude> rightTriangles
    [(8,6,10)]
    #+end_src

    最初に解の候補となる集合を生成し、それから1つ（もしくは複数）の解に辿り着くまで変換とフィルタリングを行うという手法は、関数プログラミングでよく用いられるパターン

*** ch02: 型についての話(初級)

    すべての式が型を持つ。関数も型を持つ。作成する関数について型を調べたい場合は、関数の型を明示的に書かずに型推論させるように書いて、それをインタプリタにロードして :t すると便利

    型の名前は大文字で始まる。任意の型を取る型変数は a とか小文字一文字にするのが慣習

    型クラス＝関数（メソッド）の集まり。Goでいうインターフェースで、振る舞いを定義。Eq, Ord, Show, Read(型注釈), Enum, Bounded, Num, Floating, Integral

    型クラスのインスタンスである型＝型クラスが定義している振る舞いを実装する

*** ch03: 関数

    パターンマッチを使って関数を場合分けして定義できる（特定の引数の場合はこう、といった感じ）。パターンはつねに上から検査されるので、一番上になんにでも適用されるDefault的なパターンを置くのはダメ。あとはパターンマッチ書くならすべてのパターンを列挙するようにしないと、漏れに該当するパターンにハマったときにエラーとなる。

    ファイル先頭で {-# Options -Wall -Werror #-} と書くと、コンパイル時にパターンマッチの漏れなどをチェックしてくれる

    関数の定義で複数の変数に束縛したいときは () で囲まないとエラーになる

    引数の構造に応じて定義するする内容を変えたいときはガードを使う。引数の内容に応じてIfで制御するのと似ているが、可読性が高くパターンマッチとの相性もいいのでこっち使ったほうがいい。このとき細かく分けたガードに該当しないDefault的なガード節は otherwise を使う

    関数内で何回もやっている計算は Where で中間結果として変数に割り当てて使うことができる。そして Where の中でもパターンマッチ使えるし関数も定義できる

    letを使うことで関数内の任意の箇所で変数を束縛できる（Whereは関数定義の最後）。let自体も式で let xxx (in expr) の形を取る。Whereとは異なり異なるガード節で共有されない。パターンマッチも使える

    Where ではなくて let を使うタイミングは
    - ローカルスコープに関数を作れる
    - セミコロン区切りで複数の変数を束縛できる
    - パターンマッチ使うことでタプルの分解が楽

    case によってコード上の任意の場所でパターンマッチが使える。式。どこでも使える式なので式の途中でも使える。パターンマッチ同様上から順番に検査されるので順番に注意。といってもなんかおかしい順番になってるなってコンパイラが分かる場合はエラー出してくれる。便利！

*** ch04: 再帰

    与えられた問題をより小さい部分問題に分解でき、それを繰り返した結果基底部が定義できるなら、再帰関数が定義できる。基底部が再帰の終了条件になるので、部分問題への分解が最終的に基底部に到達するか（終了条件）はよく検証する必要がある

    関数の引数にリストをとり、処理内部でリストの先頭や先頭を削除したリストを使いたい場合は、引数を記述するときに (x:xs) と書くことで処理内部で先頭 x 先頭を削除したリスト xs を使うことができる（パターンマッチ）

    また、関数の引数にリストをとり、リストを複数部分に分割して処理するような関数を定義するときはリスト内包表記が便利。リストから特定の条件を満たすもののリストを手軽に導出できる（クイックソートの例を参照）

    再帰を使う際の定跡は、まず基底部を見極め、次に、解くべき問題をより小さな部分問題へと分割する方法を考えること。基底部と部分問題さえ正しく選んだなら、全体として何が起こるかの詳細を考える必要はない

*** ch05: 高階関数

    引数として関数を持ったり、関数を返したりする関数

    Haskell ではすべての関数は一つの引数のみ持つようになっている。複数の引数を持つように見える関数は、実は「引数の最初を受け取って内部では処理し、結果として残りの引数を受け取って処理するような関数を返す」ようになっている。これをカリー化という。

    カリー化されていることによって、関数を定義した引数の数より少ない引数を渡して呼び出したときに、部分適用された関数を得ることができる。以下の通り、引数を3つ持つ関数 multiThree を、引数を一つだけ渡して呼び出した multiThree 9 (multiTwoWithNine) は、「2つの引数を受け取ってそれらと9を乗算する関数」になっている

    #+begin_src
    *Main> :t multiThree
    multiThree :: Int -> Int -> Int -> Int
    *Main> let multiTwoWithNine = multiThree 9
    *Main> multiTwoWithNine 2 3
    54
    *Main> :t multiTwoWithNine
    multiTwoWithNine :: Int -> Int -> Int
    #+end_src

    map に複数の引数を持つ関数を与えると、リストに対する引数を引いた残りの引数を持つ関数が返される

    #+begin_src
    *Main> let listOfFuns = map (*) [0..]
    *Main> (listOfFuns !! 4) 5
    20
    #+end_src

    ラムダ式とは、一回だけ必要な関数を定義する方法。通常は、高階関数に渡すために無名関数をつくるというときによく使われる。ラムダ式でもパターンマッチ書けるけど、複数パターンを定義できない。パターンに該当しないケースにぶち当たったらランタイムエラー

    畳み込み。2引数関数（+とか）と畳込みに用いる初期値（アキュムレーター）、畳み込むリストを受け取って、単一のデータを作ること。例えば sum とか

    foo a = bar b a みたいな形はカリー化によって foo = bar b に書き換えることができる(ポイントフリースタイル）

    畳み込みを使うときは空リストに対する結果にも考慮すること。空リストに対して処理しても問題ない関数なら foldl1, foldr1 が使える（与えられたリストの第一要素をアキュムレーターにするやつ）

    畳み込みを別の視点で見る。右畳み込みを、2引数関数f、アキュムレーターzとおいたとき、各リストへの関数適用と捉えると、リスト[3,4,5]に対して f 3 (f 4 (f 5 z)) と見ることができる

    scanr, scanl でアキュムレーターの中間状態を確認できる

    $演算子を用いた関数適用は右結合（優先順位が低い）で、スペースを用いた関数適用は左結合。 sum (map sqrt [1..10]) は sum $ map sqrt [1..10] と書ける。$ から行末までが引数になるようなかんじ

    map ($3) [(+4), (*2), sqrt] のように関数適用それ自身を関数とみなすこともできる

    関数結合を使うことでコードの可視性を良くすることができる。右結合なので f(g(z(x))) は (f . g . z) x と等価。ラムダで書けるケースでも関数合成を使ったほうが見やすい

    #+begin_src
    Prelude> map (\x -> negate (abs x)) [5,3,6,7,3,2,19,24]
    [-5,-3,-6,-7,-3,-2,-19,-24]
    Prelude> map (negate . abs)[5,3,6,7,3,2,19,24]
    [-5,-3,-6,-7,-3,-2,-19,-24]
    Prelude> map (negate . abs) [5,3,6,7,3,2,19,24]
    [-5,-3,-6,-7,-3,-2,-19,-24]
    #+end_src

    たくさん括弧がある式を関数合成を使って書き直したいなら、まずは一番内側の関数とその引数を書き出すことから始める。それから$をその前に置いて、その前に置かれていた関数から最後の引数を取り除き、間にドットを置いて合成

*** ch06: モジュール

    関数や型、型クラスが集まったもの

    モジュールから特定の関数をインポートするときは import Module (func) で、逆に特定の関数以外をすべてインポートする場合は import Module hiding (func)

    インポートして使いたい関数がPrelude内や他で定義されている場合は import qualified Module で就職付きインポートして、使うときは Module.func というふうにモジュール名付きで使う。モジュール名いちいちめんどいなら import qualified Module as M でインポートするモジュールに別名を与えられるので、それで M.func のように使う

    畳み込み処理時は、遅延評価のためギリギリまでアキュムレーターは評価されず、また後で使うために中間結果を保持しておくので大きいリストだとスタックオーバーフローが起きる。畳み込み時には遅延評価ではなくて正格評価がしたい！というときは Data.List の foldl' という関数を使う

    Maybe 型。なにもないときは Nothing 、値を持つときは Just X。 Rust の Option

*** ch07: 型、型クラス

    data キーワードを使って新しいデータ型を定義できる（データ宣言）。 data Bool = True | False とか。data 型名 = 値コンストラクタ... で、型名、値インスタンスは大文字から始める

    data Shape = Circle Float Float Float | Rectangle Float Float Float Float

    Circle 値コンストラクタは3つのフィールドを受け取る、と読む

    関数と同じように自作モジュールから自作クラスをエクスポートできる。値コンストラクタもエクスポートする場合はクラス名の後ろに () で値コンストラクタを書く。あるクラスの値コンストラクタをすべてエクスポートする場合は (..) をつける

    逆に値コンストラクタをエクスポートしないで代わりに補助関数を提供することで、内部実装を隠蔽し型の抽象度を上げることができる。Data.Mapなんかはそう。かわりに fromList のような補助関数が提供されている

    型コンストラクタ＝型を引数にとって新しい型を導出する。data Maybe a = Nothing | Just a とか。型を基準に一個持ち上げるイメージ。型コンストラクタは型ではないので注意

    データ宣言には型クラス制約をつけない（結局その宣言したデータ型をつかう関数において、型クラス制約が必要ならつけないといけないので、データ宣言につけるうまみがないため）

    特定の型クラスはインスタンス宣言が自動導出できる。 instance Eq X where ... とか書かなくても data X = ... deriving (Eq) で自動導出可能

    代数データ型のデータ宣言を使うことで列挙型が作れる。Enum, Bounded型クラスが便利。

    型シノニム（型同義名）。[Char] と String のようなやつ。type String = [Char] （新しいデータ型を宣言しているわけではない）。Stringに型シノニムを与えて使うことで、プログラム内でそれが示す意味をわかりやすくすることができる

    型シノニムも型引数を取れる。type AssocList k v = [(k, v)]。型引数を部分適用させて新しい型コンストラクタを作ることもできる。関数を呼ぶときに引数の数が足りないと、残りの引数を取る新しい関数が返ってくるように、型コンストラクタに型引数を一部しか与えないと、残りの型引数を取る型コンストラクタが返る

    型引数を2つとるEitherを使うことで、Maybeだけでは不十分なケースに対応できる。data Either a b = Left a | Right b deriving (Eq, Ord, Read, Show)

    自身の型をフィールドに持つデータ型も作れる（リストなど）

**** 型クラス中級講座

     独自の型クラスを作ってそのインスタンスを手動で作成する方法

     ある型Tがある型クラスCのインスタンスであるとは、型クラスCが定義する関数（メソッド）たちを型Tに対して使える、ということを意味する

     class Eq a where ... の形で作成。新しい型クラスを定義するのがclassで、型を型クラスのインスタンスにするのがinstance

     ある型クラスのサブクラスである型クラスを作ることもできる。Numの例だと冒頭に class (Eq a) => Num a where ... と書かれている。これは「ある型aをNumインスタンスにするならまずそいつはEqインスタンスじゃなきゃダメやで」ということ。型クラス宣言に型クラス制約つける

     型クラスのインスタンスが何者かを知りたければ、GHCiで:info YourTypeClassと打つ

**** Functor 型クラス

     全体を写せる（map over、変換を施す）ものの型クラス

     #+begin_src
     class Functor f where
         fmap :: (a -> b) -> f a -> f b
     #+end_src

     f は一つの型引数を取る型コンストラクタ（Maybe Intは具体型、Maybeは型コンストラクタ）。fmapは「ある型aから別の型bへの関数」と「ある型aに適用されたファンクター値」を受け取り、「ある型bに適用されたファンクター値」を返す

     #+begin_src
     map :: (a -> b) -> [a] -> [b]
     #+end_src

     map はある型から別の型への変換関数とある型のリストを取り、別の型のリストを返す。これはリストに対するfmap。以下の [] はリストに対する型コンストラクタ

     #+begin_src
     instance Functor [] where
         fmap = map
     #+end_src

     Maybe は Functor（多分？）

     Either は型引数を2つ取るから Functor じゃないと思いきや、 left だけ型引数の中に入れて自由引数を残す状態にして定義されている（Control.Monad.Instance）

     #+begin_src
     instance Functor (Either a) where
         fmap f (Right x) = Right (f x)
         fmap f (Left x) = Left x
     #+end_src

     型はラベルで、型それ自体にも種類という型がある。:kで型の種類を確認できる（:tで値の型確認）。方は値のラベルで、種類は型のラベル

*** ch08: IO

    #+begin_quote
    命令型言語では、一見すると数を処理するだけに見える簡単な関数が、処理の片手間にあなたの家に火をつけたり犬を誘拐したりしないことを保証できません。
    #+end_quote

    草

    入出力処理は純粋関数だけでは取り扱えない分野。Haskellではこういった不純な仕事と純粋なものを分割して処理できるようになっている

    putStrLn "Hello, World" は、「Hello，Worldと出力しろ」という命令ではなく「Hello, Worldと出力するIOアクションを返す」処理になる。IOアクションはmainから呼ばれるとき、あるいはdoブロックで作った別の大きなI/Oアクションの中にあるときに実行される

    Control.Monad の when 関数を使うことで、条件に合致したときだけ渡されたIOアクションと同じものを返すことができ、 if-then-else かかなくてよい（条件合致しないときは return () を返す）

    「リストに対してIOアクションを返す関数をマップし、それからシーケンスにする」という処理は頻発するので mapM が使える。関数とリストを受け取り、リストに対して関数をマップしてそれからシーケンスにする処理。IOアクションの結果が必要ないとき（printなど）は mapM_ で結果を捨てることができる

    #+begin_src
    Prelude> mapM print [1,2,3]
    1
    2
    3
    [(),(),()]
    Prelude> mapM_ print [1,2,3]
    1
    2
    3
    #+end_src

    forM はリストとリストに適用する関数を受け取り、このリストの各要素に対応するI/Oアクションを作る。それぞれのI/Oアクションの動作は、アクションを作るのに使った要素に応じたものにできる。最終的には、これらのアクションが実行された結果が何かに束縛される。（結果が必要なければ丸ごと捨ててしまうこともできる）

    mapM, forM は関数とリストどっちを長く書きたいかで決めると良さそう。リストなら後ろにおける mapM, 関数ならdo構文が後ろにおける forM

*** ch09: もっと入出力

**** ファイルとストリーム

     ストリーム：時間をかけてプログラムに入ってくる連続したデータ片

     getContents で標準入力からEOF文字まで読み込む

     「入力を文字列として受け取りそれを関数で変換して出力する」パターンは interact が使える

     プログラムを書くときは、ある入力に対してどんな出力が考えられるかという視点から考えて、その変換をする関数を書くだけ。今出力したいものは入力によって決まるので、遅延I/Oでは本当に必要になるまで入力を一切消費しない。

**** ファイルの読み書き

     openFile :: FilePath -> IOMode ->  IO Handle 。ファイルパスとIOモードを受け取ってIOハンドラを返すIOアクションを返す

     withFile :: FilePath -> IOMode -> (Handle -> IO a) -> IO a 。ファイルパスとIOモード、ハンドルを受け取ってIOアクションを返す関数を受け取って、そのファイルを開いてからなにかして閉じるというIOアクションを返す

     ファイルを読み込み、そのコンテンツを文字列として処理する関数に readFile, writeFile, appendFile 関数がある

     System.Environment でコマンドライン引数を扱う

**** ランダム性

     Haskell は参照透過性をもつので、同じ引数を与えられた関数は常に同じ結果を返す。これはランダムな値を取得したいときにすこし厄介。System.Randomモジュールを使う

     randomR で乱数の範囲を指定でき、randomRs で範囲を指定した乱数を無限に生成できる

     genStdGen というIO Stdgen型のIOアクションを提供している。これでいちいち乱数のシード値を手渡しせずに、何らかの初期データを使ってシステムのグローバル乱数ジェネレータを生成できる

**** bytestring

     ファイルを文字列として扱うと、、、遅い。文字列はリストなので遅延処理のためにサンク（thunk）が生まれ、本来はリストとして処理しなくてもいい数値などはオーバーヘッドが発生する。ここでサイズが固定されたByteStringを使う。

     正格ByteString：配列上のバイト列（無限長が作れない） Data.ByteString
     遅延ByteString：チャンクに区切られて処理される Data.ByteString.Lazy

*** ch10: 関数型問題解決法

    人間だったらこの問題をどう解くのか考える（つまり普通に解いてみる）

    Haskell のデータ構造だと、人間の解法をどう表現できるかを考える。データ構造を Haskell で操作して解を得る方法を考える

    関数の実装の前に肩宣言がどうなるかを考える
