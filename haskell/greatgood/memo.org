#+title: Learn You a Haskell for Great Good
#+author: matsuyoshi30

Haskell メモ

** Haskell とは

   非正格評価を特徴とする純粋関数型プログラミング言語

   非性格とは、関数に与えられた引数などの式はどうしても必要になるまで評価されないということ

   命令型は「何をするか」を定義し、関数型は「何であるか」を定義する

   純粋関数型は副作用を持たず、関数の処理結果が外部の環境などに作用されず、同じ引数を与えられれば常に同じ結果を返す（参照透過性）

   →ユーザーによる入力によってコンソールに出力する内容が変わる、というのも副作用

   →上記のケースは Haskell だと「関数はXXという内容をコンソールに書き出すIOモナドを生成して返却する」ように処理される


** Learn You a Haskell for Great Good

*** ch01

    演算子 +, -, *, / も関数の一つ（中置関数）

    関数はどの演算子よりも優先順位が高い

    if-then-else: if 文書くときは常に else も書く

    リストの操作には注意が必要で、結合時は結合される ++ の左のリストは先頭から末尾まで走査するので、対象のリストのサイズが大きいときはそれだけ実行時間がかかる。一方で、リストの先頭に何かを追加するような処理ははやい

    リスト内包表記によって take 10 [2,4..] が [x*2 | x <- [1..10]] と書ける

    各辺の長さが10以下で、各辺の合計が24である直角三角形の辺の組み合わせの求め方

    #+begin_src
    Prelude> let rightTriangles = [(a,b,c) | c <- [1..10], a <- [1..c], b <- [1..a], a^2 + b^2 == c^2, a+b+c==24]
    Prelude> rightTriangles
    [(8,6,10)]
    #+end_src

    最初に解の候補となる集合を生成し、それから1つ（もしくは複数）の解に辿り着くまで変換とフィルタリングを行うという手法は、関数プログラミングでよく用いられるパターン

*** ch02: 型についての話(初級)

    すべての式が型を持つ。関数も型を持つ。作成する関数について型を調べたい場合は、関数の型を明示的に書かずに型推論させるように書いて、それをインタプリタにロードして :t すると便利

    型の名前は大文字で始まる。任意の型を取る型変数は a とか小文字一文字にするのが慣習

    型クラス＝関数（メソッド）の集まり。Goでいうインターフェースで、振る舞いを定義。Eq, Ord, Show, Read(型注釈), Enum, Bounded, Num, Floating, Integral

    型クラスのインスタンスである型＝型クラスが定義している振る舞いを実装する

*** ch03: 関数

    パターンマッチを使って関数を場合分けして定義できる（特定の引数の場合はこう、といった感じ）。パターンはつねに上から検査されるので、一番上になんにでも適用されるDefault的なパターンを置くのはダメ。あとはパターンマッチ書くならすべてのパターンを列挙するようにしないと、漏れに該当するパターンにハマったときにエラーとなる。

    ファイル先頭で {-# Options -Wall -Werror #-} と書くと、コンパイル時にパターンマッチの漏れなどをチェックしてくれる

    関数の定義で複数の変数に束縛したいときは () で囲まないとエラーになる

    引数の構造に応じて定義するする内容を変えたいときはガードを使う。引数の内容に応じてIfで制御するのと似ているが、可読性が高くパターンマッチとの相性もいいのでこっち使ったほうがいい。このとき細かく分けたガードに該当しないDefault的なガード節は otherwise を使う

    関数内で何回もやっている計算は Where で中間結果として変数に割り当てて使うことができる。そして Where の中でもパターンマッチ使えるし関数も定義できる

    letを使うことで関数内の任意の箇所で変数を束縛できる（Whereは関数定義の最後）。let自体も式で let xxx (in expr) の形を取る。Whereとは異なり異なるガード節で共有されない。パターンマッチも使える

    Where ではなくて let を使うタイミングは
    - ローカルスコープに関数を作れる
    - セミコロン区切りで複数の変数を束縛できる
    - パターンマッチ使うことでタプルの分解が楽

    case によってコード上の任意の場所でパターンマッチが使える。式。どこでも使える式なので式の途中でも使える。パターンマッチ同様上から順番に検査されるので順番に注意。といってもなんかおかしい順番になってるなってコンパイラが分かる場合はエラー出してくれる。便利！

*** ch04: 再帰

    与えられた問題をより小さい部分問題に分解でき、それを繰り返した結果基底部が定義できるなら、再帰関数が定義できる。基底部が再帰の終了条件になるので、部分問題への分解が最終的に基底部に到達するか（終了条件）はよく検証する必要がある

    関数の引数にリストをとり、処理内部でリストの先頭や先頭を削除したリストを使いたい場合は、引数を記述するときに (x:xs) と書くことで処理内部で先頭 x 先頭を削除したリスト xs を使うことができる（パターンマッチ）

    また、関数の引数にリストをとり、リストを複数部分に分割して処理するような関数を定義するときはリスト内包表記が便利。リストから特定の条件を満たすもののリストを手軽に導出できる（クイックソートの例を参照）

    再帰を使う際の定跡は、まず基底部を見極め、次に、解くべき問題をより小さな部分問題へと分割する方法を考えること。基底部と部分問題さえ正しく選んだなら、全体として何が起こるかの詳細を考える必要はない
