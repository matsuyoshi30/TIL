#+title: Learn You a Haskell for Great Good
#+author: matsuyoshi30

Haskell メモ

** Haskell とは

   非正格評価を特徴とする純粋関数型プログラミング言語

   非性格とは、関数に与えられた引数などの式はどうしても必要になるまで評価されないということ

   命令型は「何をするか」を定義し、関数型は「何であるか」を定義する

   純粋関数型は副作用を持たず、関数の処理結果が外部の環境などに作用されず、同じ引数を与えられれば常に同じ結果を返す（参照透過性）

   →ユーザーによる入力によってコンソールに出力する内容が変わる、というのも副作用

   →上記のケースは Haskell だと「関数はXXという内容をコンソールに書き出すIOモナドを生成して返却する」ように処理される


** Learn You a Haskell for Great Good

*** ch01

    演算子 +, -, *, / も関数の一つ（中置関数）

    関数はどの演算子よりも優先順位が高い

    if-then-else: if 文書くときは常に else も書く

    リストの操作には注意が必要で、結合時は結合される ++ の左のリストは先頭から末尾まで走査するので、対象のリストのサイズが大きいときはそれだけ実行時間がかかる。一方で、リストの先頭に何かを追加するような処理ははやい

    リスト内包表記によって take 10 [2,4..] が [x*2 | x <- [1..10]] と書ける

    各辺の長さが10以下で、各辺の合計が24である直角三角形の辺の組み合わせの求め方

    #+begin_src
    Prelude> let rightTriangles = [(a,b,c) | c <- [1..10], a <- [1..c], b <- [1..a], a^2 + b^2 == c^2, a+b+c==24]
    Prelude> rightTriangles
    [(8,6,10)]
    #+end_src

    最初に解の候補となる集合を生成し、それから1つ（もしくは複数）の解に辿り着くまで変換とフィルタリングを行うという手法は、関数プログラミングでよく用いられるパターン

*** ch02: 型についての話(初級)

    すべての式が型を持つ。関数も型を持つ。作成する関数について型を調べたい場合は、関数の型を明示的に書かずに型推論させるように書いて、それをインタプリタにロードして :t すると便利

    型の名前は大文字で始まる。任意の型を取る型変数は a とか小文字一文字にするのが慣習

    型クラス＝関数（メソッド）の集まり。Goでいうインターフェースで、振る舞いを定義。Eq, Ord, Show, Read(型注釈), Enum, Bounded, Num, Floating, Integral

    型クラスのインスタンスである型＝型クラスが定義している振る舞いを実装する

*** ch03: 関数

    パターンマッチを使って関数を場合分けして定義できる（特定の引数の場合はこう、といった感じ）。パターンはつねに上から検査されるので、一番上になんにでも適用されるDefault的なパターンを置くのはダメ。あとはパターンマッチ書くならすべてのパターンを列挙するようにしないと、漏れに該当するパターンにハマったときにエラーとなる。

    ファイル先頭で {-# Options -Wall -Werror #-} と書くと、コンパイル時にパターンマッチの漏れなどをチェックしてくれる

    関数の定義で複数の変数に束縛したいときは () で囲まないとエラーになる

    引数の構造に応じて定義するする内容を変えたいときはガードを使う。引数の内容に応じてIfで制御するのと似ているが、可読性が高くパターンマッチとの相性もいいのでこっち使ったほうがいい。このとき細かく分けたガードに該当しないDefault的なガード節は otherwise を使う

    関数内で何回もやっている計算は Where で中間結果として変数に割り当てて使うことができる。そして Where の中でもパターンマッチ使えるし関数も定義できる

    letを使うことで関数内の任意の箇所で変数を束縛できる（Whereは関数定義の最後）。let自体も式で let xxx (in expr) の形を取る。Whereとは異なり異なるガード節で共有されない。パターンマッチも使える

    Where ではなくて let を使うタイミングは
    - ローカルスコープに関数を作れる
    - セミコロン区切りで複数の変数を束縛できる
    - パターンマッチ使うことでタプルの分解が楽

    case によってコード上の任意の場所でパターンマッチが使える。式。どこでも使える式なので式の途中でも使える。パターンマッチ同様上から順番に検査されるので順番に注意。といってもなんかおかしい順番になってるなってコンパイラが分かる場合はエラー出してくれる。便利！

*** ch04: 再帰

    与えられた問題をより小さい部分問題に分解でき、それを繰り返した結果基底部が定義できるなら、再帰関数が定義できる。基底部が再帰の終了条件になるので、部分問題への分解が最終的に基底部に到達するか（終了条件）はよく検証する必要がある

    関数の引数にリストをとり、処理内部でリストの先頭や先頭を削除したリストを使いたい場合は、引数を記述するときに (x:xs) と書くことで処理内部で先頭 x 先頭を削除したリスト xs を使うことができる（パターンマッチ）

    また、関数の引数にリストをとり、リストを複数部分に分割して処理するような関数を定義するときはリスト内包表記が便利。リストから特定の条件を満たすもののリストを手軽に導出できる（クイックソートの例を参照）

    再帰を使う際の定跡は、まず基底部を見極め、次に、解くべき問題をより小さな部分問題へと分割する方法を考えること。基底部と部分問題さえ正しく選んだなら、全体として何が起こるかの詳細を考える必要はない

*** ch05: 高階関数

    引数として関数を持ったり、関数を返したりする関数

    Haskell ではすべての関数は一つの引数のみ持つようになっている。複数の引数を持つように見える関数は、実は「引数の最初を受け取って内部では処理し、結果として残りの引数を受け取って処理するような関数を返す」ようになっている。これをカリー化という。

    カリー化されていることによって、関数を定義した引数の数より少ない引数を渡して呼び出したときに、部分適用された関数を得ることができる。以下の通り、引数を3つ持つ関数 multiThree を、引数を一つだけ渡して呼び出した multiThree 9 (multiTwoWithNine) は、「2つの引数を受け取ってそれらと9を乗算する関数」になっている

    #+begin_src
    *Main> :t multiThree
    multiThree :: Int -> Int -> Int -> Int
    *Main> let multiTwoWithNine = multiThree 9
    *Main> multiTwoWithNine 2 3
    54
    *Main> :t multiTwoWithNine
    multiTwoWithNine :: Int -> Int -> Int
    #+end_src

    map に複数の引数を持つ関数を与えると、リストに対する引数を引いた残りの引数を持つ関数が返される

    #+begin_src
    *Main> let listOfFuns = map (*) [0..]
    *Main> (listOfFuns !! 4) 5
    20
    #+end_src

    ラムダ式とは、一回だけ必要な関数を定義する方法。通常は、高階関数に渡すために無名関数をつくるというときによく使われる。ラムダ式でもパターンマッチ書けるけど、複数パターンを定義できない。パターンに該当しないケースにぶち当たったらランタイムエラー

    畳み込み。2引数関数（+とか）と畳込みに用いる初期値（アキュムレーター）、畳み込むリストを受け取って、単一のデータを作ること。例えば sum とか

    foo a = bar b a みたいな形はカリー化によって foo = bar b に書き換えることができる(ポイントフリースタイル）

    畳み込みを使うときは空リストに対する結果にも考慮すること。空リストに対して処理しても問題ない関数なら foldl1, foldr1 が使える（与えられたリストの第一要素をアキュムレーターにするやつ）

    畳み込みを別の視点で見る。右畳み込みを、2引数関数f、アキュムレーターzとおいたとき、各リストへの関数適用と捉えると、リスト[3,4,5]に対して f 3 (f 4 (f 5 z)) と見ることができる

    scanr, scanl でアキュムレーターの中間状態を確認できる

    $演算子を用いた関数適用は右結合（優先順位が低い）で、スペースを用いた関数適用は左結合。 sum (map sqrt [1..10]) は sum $ map sqrt [1..10] と書ける。$ から行末までが引数になるようなかんじ

    map ($3) [(+4), (*2), sqrt] のように関数適用それ自身を関数とみなすこともできる

    関数結合を使うことでコードの可視性を良くすることができる。右結合なので f(g(z(x))) は (f . g . z) x と等価。ラムダで書けるケースでも関数合成を使ったほうが見やすい

    #+begin_src
    Prelude> map (\x -> negate (abs x)) [5,3,6,7,3,2,19,24]
    [-5,-3,-6,-7,-3,-2,-19,-24]
    Prelude> map (negate . abs)[5,3,6,7,3,2,19,24]
    [-5,-3,-6,-7,-3,-2,-19,-24]
    Prelude> map (negate . abs) [5,3,6,7,3,2,19,24]
    [-5,-3,-6,-7,-3,-2,-19,-24]
    #+end_src

    たくさん括弧がある式を関数合成を使って書き直したいなら、まずは一番内側の関数とその引数を書き出すことから始める。それから$をその前に置いて、その前に置かれていた関数から最後の引数を取り除き、間にドットを置いて合成

*** ch06: モジュール

    関数や型、型クラスが集まったもの

    モジュールから特定の関数をインポートするときは import Module (func) で、逆に特定の関数以外をすべてインポートする場合は import Module hiding (func)

    インポートして使いたい関数がPrelude内や他で定義されている場合は import qualified Module で就職付きインポートして、使うときは Module.func というふうにモジュール名付きで使う。モジュール名いちいちめんどいなら import qualified Module as M でインポートするモジュールに別名を与えられるので、それで M.func のように使う

    畳み込み処理時は、遅延評価のためギリギリまでアキュムレーターは評価されず、また後で使うために中間結果を保持しておくので大きいリストだとスタックオーバーフローが起きる。畳み込み時には遅延評価ではなくて正格評価がしたい！というときは Data.List の foldl' という関数を使う

    Maybe 型。なにもないときは Nothing 、値を持つときは Just X。 Rust の Option

*** ch07: 型、型クラス

    data キーワードを使って新しいデータ型を定義できる（データ宣言）。 data Bool = True | False とか。data 型名 = 値コンストラクタ... で、型名、値インスタンスは大文字から始める

    data Shape = Circle Float Float Float | Rectangle Float Float Float Float

    Circle 値コンストラクタは3つのフィールドを受け取る、と読む

    関数と同じように自作モジュールから自作クラスをエクスポートできる。値コンストラクタもエクスポートする場合はクラス名の後ろに () で値コンストラクタを書く。あるクラスの値コンストラクタをすべてエクスポートする場合は (..) をつける

    逆に値コンストラクタをエクスポートしないで代わりに補助関数を提供することで、内部実装を隠蔽し型の抽象度を上げることができる。Data.Mapなんかはそう。かわりに fromList のような補助関数が提供されている

    型コンストラクタ＝型を引数にとって新しい型を導出する。data Maybe a = Nothing | Just a とか。型を基準に一個持ち上げるイメージ。型コンストラクタは型ではないので注意

    データ宣言には型クラス制約をつけない（結局その宣言したデータ型をつかう関数において、型クラス制約が必要ならつけないといけないので、データ宣言につけるうまみがないため）

    特定の型クラスはインスタンス宣言が自動導出できる。 instance Eq X where ... とか書かなくても data X = ... deriving (Eq) で自動導出可能

    代数データ型のデータ宣言を使うことで列挙型が作れる。Enum, Bounded型クラスが便利。

    型シノニム（型同義名）。[Char] と String のようなやつ。type String = [Char] （新しいデータ型を宣言しているわけではない）。Stringに型シノニムを与えて使うことで、プログラム内でそれが示す意味をわかりやすくすることができる

    型シノニムも型引数を取れる。type AssocList k v = [(k, v)]。型引数を部分適用させて新しい型コンストラクタを作ることもできる。関数を呼ぶときに引数の数が足りないと、残りの引数を取る新しい関数が返ってくるように、型コンストラクタに型引数を一部しか与えないと、残りの型引数を取る型コンストラクタが返る

    型引数を2つとるEitherを使うことで、Maybeだけでは不十分なケースに対応できる。data Either a b = Left a | Right b deriving (Eq, Ord, Read, Show)

    自身の型をフィールドに持つデータ型も作れる（リストなど）

**** 型クラス中級講座

     独自の型クラスを作ってそのインスタンスを手動で作成する方法

     ある型Tがある型クラスCのインスタンスであるとは、型クラスCが定義する関数（メソッド）たちを型Tに対して使える、ということを意味する

     class Eq a where ... の形で作成。新しい型クラスを定義するのがclassで、型を型クラスのインスタンスにするのがinstance

     ある型クラスのサブクラスである型クラスを作ることもできる。Numの例だと冒頭に class (Eq a) => Num a where ... と書かれている。これは「ある型aをNumインスタンスにするならまずそいつはEqインスタンスじゃなきゃダメやで」ということ。型クラス宣言に型クラス制約つける

     型クラスのインスタンスが何者かを知りたければ、GHCiで:info YourTypeClassと打つ

**** Functor 型クラス

     全体を写せる（map over、変換を施す）ものの型クラス

     #+begin_src
     class Functor f where
         fmap :: (a -> b) -> f a -> f b
     #+end_src

     f は一つの型引数を取る型コンストラクタ（Maybe Intは具体型、Maybeは型コンストラクタ）。fmapは「ある型aから別の型bへの関数」と「ある型aに適用されたファンクター値」を受け取り、「ある型bに適用されたファンクター値」を返す

     #+begin_src
     map :: (a -> b) -> [a] -> [b]
     #+end_src

     map はある型から別の型への変換関数とある型のリストを取り、別の型のリストを返す。これはリストに対するfmap。以下の [] はリストに対する型コンストラクタ

     #+begin_src
     instance Functor [] where
         fmap = map
     #+end_src

     Maybe は Functor（多分？）

     Either は型引数を2つ取るから Functor じゃないと思いきや、 left だけ型引数の中に入れて自由引数を残す状態にして定義されている（Control.Monad.Instance）

     #+begin_src
     instance Functor (Either a) where
         fmap f (Right x) = Right (f x)
         fmap f (Left x) = Left x
     #+end_src

     型はラベルで、型それ自体にも種類という型がある。:kで型の種類を確認できる（:tで値の型確認）。方は値のラベルで、種類は型のラベル

*** ch08: IO

    #+begin_quote
    命令型言語では、一見すると数を処理するだけに見える簡単な関数が、処理の片手間にあなたの家に火をつけたり犬を誘拐したりしないことを保証できません。
    #+end_quote

    草

    入出力処理は純粋関数だけでは取り扱えない分野。Haskellではこういった不純な仕事と純粋なものを分割して処理できるようになっている

    putStrLn "Hello, World" は、「Hello，Worldと出力しろ」という命令ではなく「Hello, Worldと出力するIOアクションを返す」処理になる。IOアクションはmainから呼ばれるとき、あるいはdoブロックで作った別の大きなI/Oアクションの中にあるときに実行される

    Control.Monad の when 関数を使うことで、条件に合致したときだけ渡されたIOアクションと同じものを返すことができ、 if-then-else かかなくてよい（条件合致しないときは return () を返す）

    「リストに対してIOアクションを返す関数をマップし、それからシーケンスにする」という処理は頻発するので mapM が使える。関数とリストを受け取り、リストに対して関数をマップしてそれからシーケンスにする処理。IOアクションの結果が必要ないとき（printなど）は mapM_ で結果を捨てることができる

    #+begin_src
    Prelude> mapM print [1,2,3]
    1
    2
    3
    [(),(),()]
    Prelude> mapM_ print [1,2,3]
    1
    2
    3
    #+end_src

    forM はリストとリストに適用する関数を受け取り、このリストの各要素に対応するI/Oアクションを作る。それぞれのI/Oアクションの動作は、アクションを作るのに使った要素に応じたものにできる。最終的には、これらのアクションが実行された結果が何かに束縛される。（結果が必要なければ丸ごと捨ててしまうこともできる）

    mapM, forM は関数とリストどっちを長く書きたいかで決めると良さそう。リストなら後ろにおける mapM, 関数ならdo構文が後ろにおける forM

*** ch09: もっと入出力

**** ファイルとストリーム

     ストリーム：時間をかけてプログラムに入ってくる連続したデータ片

     getContents で標準入力からEOF文字まで読み込む

     「入力を文字列として受け取りそれを関数で変換して出力する」パターンは interact が使える

     プログラムを書くときは、ある入力に対してどんな出力が考えられるかという視点から考えて、その変換をする関数を書くだけ。今出力したいものは入力によって決まるので、遅延I/Oでは本当に必要になるまで入力を一切消費しない。

**** ファイルの読み書き

     openFile :: FilePath -> IOMode ->  IO Handle 。ファイルパスとIOモードを受け取ってIOハンドラを返すIOアクションを返す

     withFile :: FilePath -> IOMode -> (Handle -> IO a) -> IO a 。ファイルパスとIOモード、ハンドルを受け取ってIOアクションを返す関数を受け取って、そのファイルを開いてからなにかして閉じるというIOアクションを返す

     ファイルを読み込み、そのコンテンツを文字列として処理する関数に readFile, writeFile, appendFile 関数がある

     System.Environment でコマンドライン引数を扱う

**** ランダム性

     Haskell は参照透過性をもつので、同じ引数を与えられた関数は常に同じ結果を返す。これはランダムな値を取得したいときにすこし厄介。System.Randomモジュールを使う

     randomR で乱数の範囲を指定でき、randomRs で範囲を指定した乱数を無限に生成できる

     genStdGen というIO Stdgen型のIOアクションを提供している。これでいちいち乱数のシード値を手渡しせずに、何らかの初期データを使ってシステムのグローバル乱数ジェネレータを生成できる

**** bytestring

     ファイルを文字列として扱うと、、、遅い。文字列はリストなので遅延処理のためにサンク（thunk）が生まれ、本来はリストとして処理しなくてもいい数値などはオーバーヘッドが発生する。ここでサイズが固定されたByteStringを使う。

     正格ByteString：配列上のバイト列（無限長が作れない） Data.ByteString
     遅延ByteString：チャンクに区切られて処理される Data.ByteString.Lazy

*** ch10: 関数型問題解決法

    人間だったらこの問題をどう解くのか考える（つまり普通に解いてみる）

    Haskell のデータ構造だと、人間の解法をどう表現できるかを考える。データ構造を Haskell で操作して解を得る方法を考える

    関数の実装の前に肩宣言がどうなるかを考える

*** ch11: ファンクタ−からアプリカティブファンクタ−へ

    IOもファンクターの一種。何らかの関数に渡すためにIOアクションの結果を名前に束縛しているケースでは fmap が使えるかどうか検討してみても良い。例えば

    #+begin_src
    main = do line <- getLine
             let line' = reverse line
             putStrLn $ "You said, " ++ line' ++ " backwards!"
    #+end_src

    これはこのように書ける

    #+begin_src
    main = do line <- fmap reverse getLine
             putStrLn $ "You said, " ++ line ++ " backwards!"
    #+end_src

    ファンクターの中身を複数の関数を用いて写したい（fmapに複数の関数を渡したい）ときは関数合成がよい

    関数の型表現に使う -> もファンクター。 r -> a は (->) r a と書ける。このときファンクターのインスタンス宣言は fmap f g -> (\x -> f (g x)) と定義されている

    上記は fmap :: (a -> b) -> (r -> a) -> (r -> b) 。これが意味するのは、 a から b への関数と r から a への関数を受け取って r から b への関数を返す、ということ。そしてこれは関数合成そのものである。r -> a の出力を a -> b の入力につなぎ、関数 r ->b を作る

    fmap :: (a -> b) -> f a -> f b をカリー化の観点からみる。関数とファンクター値を取ってファンクター値を返す2引数関数とも思える一方、関数を取って「元の関数に似ているけどファンクター値を取ってファンクター値を返す関数」を返す関数だと思うこともできる。 (a -> b) -> ( (f a) -> (f b) ) みたいな感じ。 fmap は関数 a -> b を受け取って関数 f a -> f b を返す。これを関数の持ち上げ（lifting）という（値から値への関数から、ファンクター値からファンクター値への持ち上げ）

**** ファンクターが従うべき法則、ファンクタ−則

     id でファンクターを写した場合、ファンクター値が変化してはいけない。fmap id をファンクター値に適用した場合、それは id をファンクター値に適用したのとおなじになる（id は引数をそのまま返す恒等写像関数）

     「fとgの合成関数でファンクター値を写したもの」と、「まずg、次にfでファンクター値を写したもの」が等しいこと。fmap (f . g) = fmap f . fmap g であること。

     Haskell では、ファンクターのインスタンスだと明示的に宣言してても上記のファンクター則にのっとっていない場合はファンクターにならない。処理系でチェックしてないので自分でテスト・証明する必要がある。ある型をファンクターのインスタンスにしようと思ったら、まずは上記のファンクター則が満たせるかどうかを検討する。

**** アプリカティブファンクター

     多引数関数でファンクター値を移すと、関数が入ったファンクター値が返ってくる。例えば、中置関数として2引数と受け取る * を例にすると、 fmap (*) (Just 3) は Just (3 *) となり、関数がファンクター値の中に入る。

     関数が入ったファンクター値と、関数が入っていないファンクター値をやりとりするにはファンクターの機能だけではできない。ここでファンクターの派生であるアプリカティブファンクターを使う

     #+begin_src
     class (Fucntor f) => Applicative f when
       pure :: a -> f a
       <*> :: f (a -> b) -> f a -> f b
     #+end_src

     まず、型クラス定義からアプリカティブはファンクターの型クラス制約を受けていることがわかる。つまり任意の型をアプリカティブにしたいならまずはファンクターにしないといけない。

     pure は任意の型の引数をとり、それをアプリカティブ値の中に入れて返す。<*> は fmap の強化版で、 fmap が (a -> b) -> f a -> f b 、普通の関数とファンクター値を受け取ってファンクター値を返すのに対し、 <*> は f (a -> b) -> f a -> f b 、関数が入っているファンクター値とファンクター値を受け取ってファンクター値を返す

     Maybe の例

     #+begin_src
     instance Applicative Maybe where
       pure = Just
       Nothing <*> _ = Nothing
       (Just f) <*> something = fmap f something
     #+end_src

     pure は Just をラップ。<*> は左辺が Nothing なら Nothing で、左辺に関数が入っているJust（ファンクター）をとったら右辺の内容にその関数を fmap で適用させる。これで Just (3*) <*> Just (4) みたいな処理ができる

     <*> は例によって部分適用がきくので、例えば pure (*) <*> Just 3 <*> Just 5 みたいに <*> を連続して記述することができる

     pure f <*> x <*> y <*> ... は fmap f <*> x <*> y <*> ... と同じ。これは <$> によって f <$> x <*> y <*> ... と書ける

     リストもアプリカティブ

     #+begin_src
     Prelude> [(*0),(+100),(^2)] <*> [1,2,3]
     [0,0,0,101,102,103,1,4,9]
     Prelude> [(+),(*)] <*> [1,2] <*> [3,4]
     [4,5,5,6,3,4,6,8]
     Prelude> (++) <$> ["ha","he","hmm"] <*> ["?","!","."]
     ["ha?","ha!","ha.","he?","he!","he.","hmm?","hmm!","hmm."]
     #+end_src

     リストでは直積のような形になるが、1つ目の要素は1つ目の関数、2つ目の要素は2つ目の関数、といった形にしたいときは ZipList を使う

     #+begin_src
     instance Applicative ZipList where
       pure x = ZipList (repeat x)
       ZipList fs <*> ZipList xs = ZipList (zipWith (\f x -> f x) fs xs)
     #+end_src

     こんなかんじ（ShowインスタンスがないのでgetZipList を使う＆Control.Applicativeをインポートする）

     #+begin_src
     Prelude Control.Applicative> getZipList $ (*) <$> ZipList [1,2,3] <*> ZipList [100,100,100]
     [100,200,300]
     Prelude Control.Applicative> getZipList $ (+) <$> ZipList [1,2,3] <*> ZipList [100,100,100]
     [101,102,103]
     Prelude Control.Applicative> getZipList $ (max) <$> ZipList [1,2,3,4,5,6] <*> ZipList [5,3,1,2]
     [5,3,3,4]
     Prelude Control.Applicative> getZipList $ (,,) <$> ZipList "dog" <*> ZipList "cat" <*> ZipList "rat"
     [('d','c','r'),('o','a','a'),('g','t','t')]
     #+end_src

     ファンクターのようにアプリカティブにも従うべき法則がある
     - pure f <*> x = fmap f x
     - pure id <*> v = v
     - pure (.) <*> u <*> v <*> w = u <*> (v <*> w)
     - pure f <*> pure x = pure (f x)
     - u <*> pure y = pure ($ y) <*> u

     liftA2 という関数（Control.Applicative）で、1つの関数を2つのアプリカティブ値に適用できる

     アプリカティブファンクターをうまく使うことで、IOのように実行しないと結果が取り出せない処理や、リストを扱うときの非決定性計算、失敗するかもしれない計算をうまく組み合わせることができる

*** ch12: monoid

    ZipList a 型のデータ宣言は以下のように書ける

    #+begin_src
    data ZipList a = ZipList [a]
    -- もしくは
    data ZipList a = ZipList { getZipList :: [a] }
    #+end_src

    上の例ではdataキーワードを、既存の型を別の型でくるむために使っている。前の章では instance を使って ZipList をアプリカティブファンクターのインスタンスにしている様子を見た（既存の型をある型クラスのインスタンスにするのは deriving か instance を使う）

    newtype キーワードによって、「1つの型を取りそれをなにかに包んで別の型に見せる」ことができる

    #+begin_src
    newtype ZipList a = ZipList { getZipList :: [a] }
    #+end_src
    https://hackage.haskell.org/package/base-4.15.0.0/docs/src/Control-Applicative.html#ZipList

    data の代わりに newtype を使うほうが高速。だが newtype は値コンストラクタを一つしか持てない、かつその値コンストラクタが持てるフィールドは1つのみ。

    dataキーワードで定義した型とnewtypeキーワードで定義した型はプログラマの視点からはそっくりに見えるかもしれない（どちらにも値コンストラクタとフィールドがある）が、実際には2つの異なったメカニズム

    dataはオリジナルな型を無から作り出すものに対し、newtypeは既存の型をもとに、はっきり区別される新しい型を作るもの。dataに対するパターンマッチが箱から中身を取り出す操作なのに対し、newtypeに対するパターンマッチは、ある型を別の型へ直接変換する操作

    整理すると、
    - type は型シノニムを作るものtype IntList = [Int]
      型シグニチャを整理してわかりやすくするために使う
    - newtype は既存の型を包んで新しい型を作るもの
      値コンストラクタが一つだけ、持てるフィールドも一つだけの data とみなせる
    - data は自作の新しい方を作るもの

**** Monoid クラス

     #+begin_src
     class Monoid m where
       mempty :: m
       mapped :: m -> m -> m
       mconcat :: [m] -> m
       mconcat = foldr mapped mempty
     #+end_src

     結合的な二項演算子（2引数関数）と、その演算に関する単位元からなる構造。結合的とは、複数の引数と受け取って値の間の関数適用順序を変えても結果が変わらないということ。（リストの ++ とか、算術の * とか）。単位元とは、それと他の引数を演算に適用させたとき、結果は他の引数と同じになるもの。（リスト結合の [] とか、乗算の1とか）

     Monoid則（Haskell側ではチェックしてくれないので自分で気をつける）
     - mempty `mappend` x = x
     - x ` mappend` mempty = x
     - (x `mappend` y) `mappend` z = x `mappend` (y `mappend` z)

     ある型に対して同じ型クラスのインスタンスを複数定義したかったら、newtypeに包んで新しい型をインスタンスにするという方法がある

     #+begin_src
     newtype Product a = Product { getProduct :: a } deriving (Eq, Ord, Read, Show, Rounded)
     instance Num a => Monoid (Product a) where
       mempty = Product 1
       Product x `mappend` Product y = Product (x * y)
     #+end_src
     https://hackage.haskell.org/package/base-4.12.0.0/docs/src/Data.Semigroup.Internal.html#line-269

     Sum も近くに定義されてる

     Any は || をモノイド演算、Falseを単位元としたモノイドのインスタンス
     All は && をモノイド演算、Trueを単位元としたモノイドのインスタンス

     Maybe a をモノイドにする方法も複数ある。まずは a がモノイドである型クラス制約付きでMaybe aをモノイドのインスタンスにするケース。単位元が Nothing で mappend の引数のいずれかが Nothing ならそうでない引数を返し、 mappend の引数がいずれも Just なら Just (a `mappend` b) を返す（a がモノイドであることが型クラス制約で決まっているので）

     または、mappend の第一引数を返して第二引数は無視するという First a 。逆に第一引数を無視して第二引数を返す Last a もある
     https://hackage.haskell.org/package/base-4.12.0.0/docs/src/Data.Monoid.html#line-126

**** Monoid で畳み込み

     畳み込みできるデータ構造：Foldable

*** ch13: Monad

    - ファンクター
      関数で写せる（処理できる）もの。リストやMaybeなど。fmapという型メソッドを持ち、これは「aという型のデータを受け取ってbを返す関数と、ファンクター値a」を受け取り、ファンクター値bを返す。
    - アプリカティブ
      ファンクターを強化したやつ。データ型に文脈をもたせたり、すでにファンクターに包まれている値同士を計算したりできる。「型aを受け取りアプリカティブ値aを返す」pure関数と、「アプリカティブ値の中にある関数と、アプリカティブ値」を受け取り、アプリカティブ値の中にある関数が適用されたアプリカティブ値bを返す<*>関数を持つ。

    モナドとはアプリカティブファンクターの強化版。「普通の値aを取って文脈付きの値を返す関数に、文脈付きの値m aを渡す」ことを実現するデータ型。 (Monad m) => m a -> (a -> m b) -> m b という型メソッド（バインド関数 >>=）を持つ。（変な値を、普通の値をとって変な値を返す関数に適用する）

    #+begin_src
    class Monad m where
      return :: a -> m a -- Applicative の pure と同じ
      (>>=) :: m a -> (a -> m b) -> m b
    #+end_src

    綱渡りの例で、失敗の文脈をもつ値の計算処理をシンプルな記法でサポートできた

    do記法によって複数のモナド値を糊付けできる（IOモナドでやったように）。パターンマッチも使える。パターンに合致しないときはモナド型クラスのfailが呼ばれる（デフォルトでは異常終了するようになっているが、通常はインスタンスの中で独自に定義している）
    https://hackage.haskell.org/package/transformers-0.5.6.2/docs/src/Control.Monad.Trans.Maybe.html#line-159

    リストの非決定性はモナドでうまく焼きなおせる

    #+begin_src
    instance Monad [] where
      return x = [x]
      xs >>= f = concat (map f xs)
      fail _ = []
    #+end_src

    Maybeのときと同様に、 >>= を使うことでリストをいくつでも連結して非決定性を伝播させることができる

    #+begin_src
    *Main> [1,2] >>= \n -> ['a','b'] >>= \ch -> return (n, ch)
    [(1,'a'),(1,'b'),(2,'a'),(2,'b')]
    #+end_src

**** モナド則

     ファンクター、アプリカティブと同じように、ある型がモナドのインスタンスだからといって下記に示すモナド則を満たしていないものはモナドでない。そしてそれはプログラマの責任でモナド則を満たす必要がある

     - 左恒等性
       return x >>= f は f x と等価であるということ（通常の値に関数を適用）
     - 右恒等性
       m >>= return はただの m であるということ（モナドはモナドで return）
     - 結合法則
       >>= でもなど適用関数を連鎖的に処理するとき、適用する順番はなんでもよいということ

*** ch14: a few Monad

    Writer モナド。普通の値にMonoidのおまけがついたもの

    計算途中の結果をログのように追加していき、最後にログ全体を返す事ができる。値とログのペアがモナド値で、普通の値を受け取って値とログのペア（モナド）を返す関数を適用させると、すでに持っていたログの情報を失わずログを追加していく

    #+begin_src
    newtype Writer w a = Writer { runWriter :: (a, w) }

    instance (Monoid w) => Monad (Writer w) where
      return x = Writer (x, mempty)
      (Writer (x, v)) >>= f = let (Writer (y, v')) = f x in Writer (y, v `mappend` v')
    #+end_src
    https://hackage.haskell.org/package/mtl-2.2.1/docs/src/Control.Monad.Writer.Class.html

    モノイド値を結合するとき、非効率なリストには注意する。 ++ は右結合であればよいが左結合では効率が落ちる

    モナドとしての関数

    #+begin_src
    instance Monad ((->) r) where
      return x = _ -> x
      h >>= f = \w -> f (h w) w
    #+end_src
    https://hackage.haskell.org/package/base-4.12.0.0/docs/src/GHC.Base.html#line-828

    状態を扱う State モナド（乱数ジェネレータの例のような、値と新しい状態を生成する関数のペア）

    #+begin_src
    newtype State s a = State { runState :: s -> (a, s) }
    #+end_src

    MonadState 型クラスでは、現在の状態を取得する get と、状態を引数にとって「現在の状態を受け取った状態で上書きする」関数 put を提供している

    詳細なエラー情報を持つには Either e a をつかう。Left がエラー、Right が実際の値

    #+begin_src
    instance (Error e) => Monad (Either e) where
      return x = Right x -- 成功
      Right >>= f = Right f x
      Left err >>= f = Left err -- 失敗なので関数を適用としてももともと保持していたエラー値を返す
      fail msg = Left (strMsg msg)
    #+end_src

**** モナディック関数

     モナド値を操作したりモナド値を返したり、そのどっちもやったりする関数

     liftM で関数とモナド値をとり、関数によってモナド値を写す。つまり fmap 。liftM :: (Monad m) => (a -> b) -> m a -> m b

     モナドであればアプリカティブだしファンクター。モナドの型クラス制約をつけてから、 pure は return で <*> は ap 、とすることでアプリカティブに、また liftM は fmap 、とすることでファンクターになる

     入れ子になったモナド値（Just (Just 3) みたいなやつ）は join で平らにならすことができる。 join :: (Monad m) => m (m a) -> m a

     m >>= f は join (fmap f m) と同じ

     filter のモナド値扱える版、 filterM :: (Monad m) => (a -> m Bool) -> [a] -> m [a]

     fold のモナド版、 foldM

     <=< を使ってもナディック関数を合成

*** ch15: Zipper

    Haskell は参照透過性をもつ。「更新」とは、特定のメモリ上の値を変えるのではなく、その値をもとに新しい値を作り出す。でも、まあまあ複雑なデータ構造についていちいち内容を覚えて更新処理したりするのはめんどくさい

    Zipper という機能を使ってデータ構造の一部分に注目し、その操作を効率的にする


** 参考

   - http://sugoihaskell.github.io/
   - https://ja.wikibooks.org/wiki/Haskell/%E5%9C%8F%E8%AB%96
