#+title: Learn You a Haskell for Great Good
#+author: matsuyoshi30

Haskell メモ

** Haskell とは

   非正格評価を特徴とする純粋関数型プログラミング言語

   非性格とは、関数に与えられた引数などの式はどうしても必要になるまで評価されないということ

   命令型は「何をするか」を定義し、関数型は「何であるか」を定義する

   純粋関数型は副作用を持たず、関数の処理結果が外部の環境などに作用されず、同じ引数を与えられれば常に同じ結果を返す（参照透過性）

   →ユーザーによる入力によってコンソールに出力する内容が変わる、というのも副作用

   →上記のケースは Haskell だと「関数はXXという内容をコンソールに書き出すIOモナドを生成して返却する」ように処理される


** Learn You a Haskell for Great Good

*** ch01

    演算子 +, -, *, / も関数の一つ（中置関数）

    関数はどの演算子よりも優先順位が高い

    if-then-else: if 文書くときは常に else も書く

    リストの操作には注意が必要で、結合時は結合される ++ の左のリストは先頭から末尾まで走査するので、対象のリストのサイズが大きいときはそれだけ実行時間がかかる。一方で、リストの先頭に何かを追加するような処理ははやい

    リスト内包表記によって take 10 [2,4..] が [x*2 | x <- [1..10]] と書ける

    各辺の長さが10以下で、各辺の合計が24である直角三角形の辺の組み合わせの求め方

    #+begin_src
    Prelude> let rightTriangles = [(a,b,c) | c <- [1..10], a <- [1..c], b <- [1..a], a^2 + b^2 == c^2, a+b+c==24]
    Prelude> rightTriangles
    [(8,6,10)]
    #+end_src

    最初に解の候補となる集合を生成し、それから1つ（もしくは複数）の解に辿り着くまで変換とフィルタリングを行うという手法は、関数プログラミングでよく用いられるパターン

*** ch02: 型についての話(初級)

    すべての式が型を持つ。関数も型を持つ。作成する関数について型を調べたい場合は、関数の型を明示的に書かずに型推論させるように書いて、それをインタプリタにロードして :t すると便利

    型の名前は大文字で始まる。任意の型を取る型変数は a とか小文字一文字にするのが慣習

    型クラス＝関数（メソッド）の集まり。Goでいうインターフェースで、振る舞いを定義。Eq, Ord, Show, Read(型注釈), Enum, Bounded, Num, Floating, Integral

    型クラスのインスタンスである型＝型クラスが定義している振る舞いを実装する

*** ch03: 関数

    パターンマッチを使って関数を場合分けして定義できる（特定の引数の場合はこう、といった感じ）。パターンはつねに上から検査されるので、一番上になんにでも適用されるDefault的なパターンを置くのはダメ。あとはパターンマッチ書くならすべてのパターンを列挙するようにしないと、漏れに該当するパターンにハマったときにエラーとなる。

    ファイル先頭で {-# Options -Wall -Werror #-} と書くと、コンパイル時にパターンマッチの漏れなどをチェックしてくれる

    関数の定義で複数の変数に束縛したいときは () で囲まないとエラーになる

    引数の構造に応じて定義するする内容を変えたいときはガードを使う。引数の内容に応じてIfで制御するのと似ているが、可読性が高くパターンマッチとの相性もいいのでこっち使ったほうがいい。このとき細かく分けたガードに該当しないDefault的なガード節は otherwise を使う

    関数内で何回もやっている計算は Where で中間結果として変数に割り当てて使うことができる。そして Where の中でもパターンマッチ使えるし関数も定義できる

    letを使うことで関数内の任意の箇所で変数を束縛できる（Whereは関数定義の最後）。let自体も式で let xxx (in expr) の形を取る。Whereとは異なり異なるガード節で共有されない。パターンマッチも使える

    Where ではなくて let を使うタイミングは
    - ローカルスコープに関数を作れる
    - セミコロン区切りで複数の変数を束縛できる
    - パターンマッチ使うことでタプルの分解が楽

    case によってコード上の任意の場所でパターンマッチが使える。式。どこでも使える式なので式の途中でも使える。パターンマッチ同様上から順番に検査されるので順番に注意。といってもなんかおかしい順番になってるなってコンパイラが分かる場合はエラー出してくれる。便利！

*** ch04: 再帰

    与えられた問題をより小さい部分問題に分解でき、それを繰り返した結果基底部が定義できるなら、再帰関数が定義できる。基底部が再帰の終了条件になるので、部分問題への分解が最終的に基底部に到達するか（終了条件）はよく検証する必要がある

    関数の引数にリストをとり、処理内部でリストの先頭や先頭を削除したリストを使いたい場合は、引数を記述するときに (x:xs) と書くことで処理内部で先頭 x 先頭を削除したリスト xs を使うことができる（パターンマッチ）

    また、関数の引数にリストをとり、リストを複数部分に分割して処理するような関数を定義するときはリスト内包表記が便利。リストから特定の条件を満たすもののリストを手軽に導出できる（クイックソートの例を参照）

    再帰を使う際の定跡は、まず基底部を見極め、次に、解くべき問題をより小さな部分問題へと分割する方法を考えること。基底部と部分問題さえ正しく選んだなら、全体として何が起こるかの詳細を考える必要はない

*** ch05: 高階関数

    引数として関数を持ったり、関数を返したりする関数

    Haskell ではすべての関数は一つの引数のみ持つようになっている。複数の引数を持つように見える関数は、実は「引数の最初を受け取って内部では処理し、結果として残りの引数を受け取って処理するような関数を返す」ようになっている。これをカリー化という。

    カリー化されていることによって、関数を定義した引数の数より少ない引数を渡して呼び出したときに、部分適用された関数を得ることができる。以下の通り、引数を3つ持つ関数 multiThree を、引数を一つだけ渡して呼び出した multiThree 9 (multiTwoWithNine) は、「2つの引数を受け取ってそれらと9を乗算する関数」になっている

    #+begin_src
    *Main> :t multiThree
    multiThree :: Int -> Int -> Int -> Int
    *Main> let multiTwoWithNine = multiThree 9
    *Main> multiTwoWithNine 2 3
    54
    *Main> :t multiTwoWithNine
    multiTwoWithNine :: Int -> Int -> Int
    #+end_src

    map に複数の引数を持つ関数を与えると、リストに対する引数を引いた残りの引数を持つ関数が返される

    #+begin_src
    *Main> let listOfFuns = map (*) [0..]
    *Main> (listOfFuns !! 4) 5
    20
    #+end_src

    ラムダ式とは、一回だけ必要な関数を定義する方法。通常は、高階関数に渡すために無名関数をつくるというときによく使われる。ラムダ式でもパターンマッチ書けるけど、複数パターンを定義できない。パターンに該当しないケースにぶち当たったらランタイムエラー

    畳み込み。2引数関数（+とか）と畳込みに用いる初期値（アキュムレーター）、畳み込むリストを受け取って、単一のデータを作ること。例えば sum とか

    foo a = bar b a みたいな形はカリー化によって foo = bar b に書き換えることができる(ポイントフリースタイル）

    畳み込みを使うときは空リストに対する結果にも考慮すること。空リストに対して処理しても問題ない関数なら foldl1, foldr1 が使える（与えられたリストの第一要素をアキュムレーターにするやつ）

    畳み込みを別の視点で見る。右畳み込みを、2引数関数f、アキュムレーターzとおいたとき、各リストへの関数適用と捉えると、リスト[3,4,5]に対して f 3 (f 4 (f 5 z)) と見ることができる

    scanr, scanl でアキュムレーターの中間状態を確認できる

    $演算子を用いた関数適用は右結合（優先順位が低い）で、スペースを用いた関数適用は左結合。 sum (map sqrt [1..10]) は sum $ map sqrt [1..10] と書ける。$ から行末までが引数になるようなかんじ

    map ($3) [(+4), (*2), sqrt] のように関数適用それ自身を関数とみなすこともできる

    関数結合を使うことでコードの可視性を良くすることができる。右結合なので f(g(z(x))) は (f . g . z) x と等価。ラムダで書けるケースでも関数合成を使ったほうが見やすい

    #+begin_src
    Prelude> map (\x -> negate (abs x)) [5,3,6,7,3,2,19,24]
    [-5,-3,-6,-7,-3,-2,-19,-24]
    Prelude> map (negate . abs)[5,3,6,7,3,2,19,24]
    [-5,-3,-6,-7,-3,-2,-19,-24]
    Prelude> map (negate . abs) [5,3,6,7,3,2,19,24]
    [-5,-3,-6,-7,-3,-2,-19,-24]
    #+end_src

    たくさん括弧がある式を関数合成を使って書き直したいなら、まずは一番内側の関数とその引数を書き出すことから始める。それから$をその前に置いて、その前に置かれていた関数から最後の引数を取り除き、間にドットを置いて合成
